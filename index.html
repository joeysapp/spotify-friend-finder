<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>joeysapp.github.io - p5 playground</title>
	<link rel="shortcut icon" type="image/png" href="favicon.gif"/>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/p5.min.js"></script>
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/addons/p5.sound.min.js"></script> -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/addons/p5.dom.min.js"></script>
	<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>

	<style>
	  	body {
	  		font-family: Helvetica;
	  		font-size: 1em;
	  		font-color: black;
	  		margin: 0;
	  	}	

	  	#greeting {
	  		font-size:2em;
			height: 100%;
			width: 100%;
			display: flex;
			position: fixed;
			align-items: center;
			justify-content: center;
			opacity: 1;
			-webkit-transition: opacity 1000ms linear;
			transition: opacity 1000ms linear;

	  	}	

	  	#view {
	  		z-index: -1;
	  	}
	</style>

	<script>
		window.addEventListener('scroll', function(){
			window.scrollTo(0,0);
		});

	  	var sketch = function(p){
	  		var canvas;
	  		var nodes = [];
	  		var to_add = [];
	  		var divs = [];
	  		var new_w = 0;
	  		var t = 0;
	  		var adder = true;

	  		p.setup = function(){
				this.canvas = p.createCanvas(p.windowWidth, p.windowHeight);
				this.canvas.parent('view');
				this.canvas.style('z-index:-1');
				this.canvas.position(0,0);
				p.ellipseMode(p.CENTER);
				// p.blendMode(p.DARKEST);
			}

			p.draw = function(){
				t += 0.1;
				p.background(255);
				// so I think instead of forEach I should do mapping?
				nodes.forEach(function(e,idx){
					if (e.held){
						// Adding more on holding! 
						if (adder){

						}

						var vel = p.createVector(0, 0.01*e.w);
						e.w += 1;
						// Dampening on our vel!
						vel.mult(-1);
						vel.normalize();
						vel.mult(0.1);

						var g = p.createVector(0, e.w*0.16);


					} else { 
						// velocity already exists! (i.e. isn't (0,0))
						var vel = e.vel.copy();

						// Dampening on our vel!
						vel.mult(-1);
						vel.normalize();
						vel.mult(0.22);
						var g = p.createVector(0, 0.2*e.w).limit(32);
					}
					// velocity
					e.applyForce(vel);
					// gravity!
					e.applyForce(g);
					// wind so it's not boring!
					// e.applyForce(p.createVector(0.3, 0));


					// so this is O(n) right now, but we
					// have to check every other element
					// for collision, so O(n^2)


					nodes.forEach(function(e2,idx2){
						if (e == e2) {
						} else {
							if (e.collideWith(e.pos,e2.pos,e.w,e2.w)){
								e.vel.mult(-1);
							}
						}
					})
					e.update();
					e.checkEdges();
					e.display();
				});
			}

			p.touchStarted = function(){
				$('#greeting').remove();

				new_w = p.frameCount;

				var amt = 1
				var div = 32;
				// Mobile, user touches!
				if (p.touches.length > 1){
					p.touches.forEach(function(e,idx){
						for (var i = 0; i < amt; i++){
							var c = p.random(1);
							var col = 0;
							if (c < 0.33){
								var col = p.color(0, 255, 255, 80);
							} else if (c < 0.66){
								var col = p.color(255, 0, 255, 80);
							} else {
								var col = p.color(255, 255, 0, 80);
							}

							var px = e.x;
							var py = e.y;
							var pn = p.noise(px/div,py/div);

							var vx = 0;
							var vy = 0;
							var tmp = new Node(p.createVector(px,py), p.createVector(vx,vy), 64, col);

							nodes.push(tmp);
						}
					});
				} else {
					for (var i = 0; i < amt; i++){
							var c = p.random(1);
							var col = 0;
							if (c < 0.33){
								var col = p.color(0, 255, 255, 80);
							} else if (c < 0.66){
								var col = p.color(255, 0, 255, 80);
							} else {
								var col = p.color(255, 255, 0.80);
							}
						var px = p.mouseX;
						var py = p.mouseY;
						var pn = p.noise(px/div,py/div);

						var vx = Math.random(1) > 0.5 ? -2 : 2;
						var vy = 0;
						var tmp = new Node(p.createVector(px,py), p.createVector(vx,vy), 64, col);
						nodes.push(tmp);
					}
				}

				// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
				// So this is in-place!! how cool@$!34
				nodes.sort(function(a,b){
					if (p.hue(a.col) < p.hue(b.col)){
						return -1;
					} else if (p.hue(a.col) > p.hue(b.col)){
						return 1;
					}
					return 0;
				});

				// told to do this for browser safety fyi
				return false;
			}

			p.touchEnded = function(){
				nodes.forEach(function(e){
					if (e.held){
						e.held = false;
					}
				});
				// told to do this for browser safety fyi
				return false;
			}

			class NodeSystem {}

			class Node {
		  		constructor(pos, vel, w, col){
			  		this.pos = pos;
			  		this.vel = vel;
			  		this.acc = p.createVector(0,0);
			  		this.held = true;
			  		this.w = w;
			  		this.col = col;
			  	}

			  	collideWith(sx,sy,ex,ey,r1,r2){
					return p.dist(sx,sy,ex,ey) <= (r1/4 - 2)+(r2/4 - 2);
			  	}

			  	applyForce(force){
			  		var f = p5.Vector.div(force,this.w);
			  		this.acc.add(f);
			  	}

				update(){
					// Ok so I should be updating the velocity here too.
					// Because while the user is holding (after creation)
					// we should be making sure gravity is effecting it too
					this.vel.add(this.acc);
					this.pos.add(this.vel);
					this.acc.mult(0);
			  	}

			  	checkEdges(){
					if (this.pos.x > p.windowWidth-this.w/2) {
				      this.vel.x *= -1;
				      this.pos.x = p.windowWidth-this.w/2-1;
				    } else if (this.pos.x < this.w/2) {
				      this.vel.x *= -1;
				      this.pos.x = this.w/2+1;
				    }

				    if (this.pos.y > p.windowHeight-this.w/2){
				    	this.vel.y *= -1;
				    	this.pos.y = p.windowHeight-this.w/2-1;

				    }
			  	}
		  		display(){
		  			p.fill(this.col);
		  			// p.stroke(0);
		  			// p.strokeWeight(2);
		  			p.strokeWeight(1);
		  			p.stroke(p.brightness(this.col)-24);


		  			p.push();
		  			p.translate(this.pos.x,this.pos.y);
		  			p.ellipse(0,0, this.w, this.w);

		  			// Showing velocity!
		  			p.stroke(255);
		  			p.strokeWeight(0);

		  			var sx = this.pos.x;
		  			var sy = this.pos.y;

		  			// linear view!
		  			// var ex = sx + this.vel.x*2;
		  			// var ey = sy + this.vel.y*2;

		  			// exponential view! powers of 2. kinda cool
		  			// var ex = sx + Math.pow(this.vel.x,2)/8;
		  			// var ey = sy + Math.pow(this.vel.y,2)/8;		
		  			var ex = sx + ((this.vel.x < 0) ? -Math.pow(this.vel.x,2)/8 : Math.pow(this.vel.x,2)/2);
		  			var ey = sy + ((this.vel.y < 0) ? -Math.pow(this.vel.y,2)/8 : Math.pow(this.vel.y,2)/2);

		  			p.fill(0);

		  			// p.rotate(-p.PI/16);
		  			p.strokeWeight(4);
		  			p.stroke(0, 200);

		  			p.line(0,0,((this.vel.x < 0) ? -Math.pow(this.vel.x,2)/8 : Math.pow(this.vel.x,2)/2),((this.vel.y < 0) ? -Math.pow(this.vel.y,2)/8 : Math.pow(this.vel.y,2)/2));
		  			// p.rect(0,0,this.vel.x+this.vel.y,this.vel.x+this.vel.y);
		  			p.pop();
		  		}
		  	}
	  	}

		var gamewindow = new p5(sketch);
	</script>
</head>

<body>
	<div id="greeting">
		Click me!
	</div>
	<div id="view"></div>
</body>

</html>


